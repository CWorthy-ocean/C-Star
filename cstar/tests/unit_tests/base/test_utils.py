import pytest
from unittest import mock
from cstar.base.utils import (
    _update_user_dotenv,
    _clone_and_checkout,
    _get_repo_head_hash,
    _get_repo_remote,
    _get_hash_from_checkout_target,
    _calculate_node_distribution,
    _replace_text_in_file,
    _list_to_concise_str,
    _dict_to_tree,
)


def test_update_user_dotenv(tmp_path):
    """Tests `_update_user_dotenv` for creating and appending to an environment file.

    Verifies:
    - If `~/.cstar.env` does not exist, `_update_user_dotenv` creates the file with base content prepended.
    - If `~/.cstar.env` exists, `_update_user_dotenv` appends the new content without duplicating the base content.

    Fixtures
    ----------
    tmp_path : Path
        Pytest fixture providing a temporary directory for isolated filesystem operations.

    Mocks
    -----
    `~/.cstar.env` : pathlib.Path
        Mocked to point to a temporary file within `tmp_path`.

    Asserts
    -------
    - After the first call, the file content matches the expected base content plus `initial_env_content`.
    - After the second call, the new content is appended correctly.
    """
    # Test environment variable content
    initial_env_content = "FAKE_VAR=hello"
    additional_env_content = "ANOTHER_VAR=world"

    # Temporary environment file path within the temporary directory
    mock_env_file = tmp_path / ".cstar.env"

    # Patch the `Path("~/.cstar.env").expanduser()` call to point to `mock_env_file`
    with mock.patch("pathlib.Path.expanduser", return_value=mock_env_file):
        # First call: File does not exist, should create and write base content + initial_env_content
        _update_user_dotenv(initial_env_content)
        assert mock_env_file.exists()

        # Read the content of the file
        with open(mock_env_file, "r") as f:
            written_content = f.read()

        # Expected content after the first call
        expected_base_content = (
            "# This file was generated by C-Star and is specific to your machine. "
            + "# It contains environment information related to your cases & their dependencies. "
            + "# You can safely delete this file, but C-Star may prompt you to re-install things if so.\n"
        )
        expected_first_write = expected_base_content + initial_env_content

        # Assert the file content matches the expected content
        assert written_content == expected_first_write

        # Second call: File exists, should append additional_env_content without duplicating base content
        _update_user_dotenv(additional_env_content)

        # Read the content of the file after the second call
        with open(mock_env_file, "r") as f:
            final_written_content = f.read()

        # Expected content after the second call
        expected_second_write = expected_first_write + additional_env_content

        # Assert the final content matches the expected content
        assert final_written_content == expected_second_write


class TestCloneAndCheckout:
    """Tests for `utils._clone_and_checkout` function, verifying it handles both success
    and failure cases for git clone and checkout operations.

    Mocks
    -----
    subprocess.run : Mock
        Used to simulate success or failure of `git clone` and `git checkout` commands.
    """

    def setup_method(self):
        """Sets up common parameters and patches subprocess for all tests."""
        self.source_repo = "https://example.com/repo.git"
        self.local_path = "/dummy/path"
        self.checkout_target = "main"

        # Patch subprocess.run for all tests
        self.patch_subprocess_run = mock.patch("subprocess.run")
        self.mock_subprocess_run = self.patch_subprocess_run.start()

    def teardown_method(self):
        """Stops patching subprocess after each test."""
        self.patch_subprocess_run.stop()

    def test_clone_and_checkout_success(self):
        """Test that `_clone_and_checkout` runs successfully when both clone and
        checkout commands succeed.

        Asserts
        -------
        - Ensures `subprocess.run` is called twice with the correct arguments.
        """
        # Set the mock to simulate successful clone and checkout commands
        self.mock_subprocess_run.return_value = mock.Mock(returncode=0, stderr="")

        # Call the function
        _clone_and_checkout(self.source_repo, self.local_path, self.checkout_target)

        # Validate subprocess.run is called twice (clone and checkout)
        clone_call = self.mock_subprocess_run.call_args_list[0]
        checkout_call = self.mock_subprocess_run.call_args_list[1]

        # Check the clone command arguments
        assert clone_call[0][0] == f"git clone {self.source_repo} {self.local_path}"
        # Check the checkout command with correct directory and target
        assert checkout_call[1]["cwd"] == self.local_path
        assert checkout_call[0][0] == f"git checkout {self.checkout_target}"

    def test_clone_and_checkout_clone_failure(self):
        """Test `_clone_and_checkout` raises RuntimeError if `git clone` fails.

        Asserts
        -------
        - Verifies RuntimeError is raised with an appropriate error message on clone failure.
        """

        # Simulate failure in the clone command
        self.mock_subprocess_run.side_effect = [
            mock.Mock(returncode=1, stderr="Error: clone failed."),
            mock.Mock(returncode=0),  # Checkout won't be reached
        ]

        # Check that the function raises a RuntimeError on clone failure
        with pytest.raises(RuntimeError, match="Error 1 when cloning"):
            _clone_and_checkout(self.source_repo, self.local_path, self.checkout_target)

    def test_clone_and_checkout_checkout_failure(self):
        """Test `_clone_and_checkout` raises RuntimeError if `git checkout` fails.

        Asserts
        -------
        - Verifies RuntimeError is raised with an appropriate error message on checkout failure.
        """
        # Simulate successful clone and failed checkout
        self.mock_subprocess_run.side_effect = [
            mock.Mock(returncode=0, stderr=""),
            mock.Mock(returncode=1, stderr="Error: checkout failed."),
        ]

        # Check that the function raises a RuntimeError on checkout failure
        with pytest.raises(RuntimeError, match="Error 1 when checking out"):
            _clone_and_checkout(self.source_repo, self.local_path, self.checkout_target)


def test_get_repo_remote():
    """Test `_get_repo_remote` to confirm it returns the correct remote URL when `git
    remote get-url origin` succeeds.

    Asserts
    -------
    - Ensures the returned remote URL matches the expected URL.
    """
    local_path = "/dummy/path"
    expected_url = "https://example.com/repo.git"

    # Patch subprocess.run to simulate successful git command
    with mock.patch("subprocess.run") as mock_run:
        mock_run.return_value = mock.Mock(returncode=0, stdout=expected_url + "\n")

        # Call the function
        result = _get_repo_remote(local_path)

        # Check the function output and subprocess call arguments
        assert result == expected_url
        mock_run.assert_called_once_with(
            f"git -C {local_path} remote get-url origin",
            shell=True,
            capture_output=True,
            text=True,
        )


def test_get_repo_head_hash():
    """Test `_get_repo_head_hash` to confirm it returns the correct commit hash when
    `git rev-parse HEAD` succeeds.

    Asserts
    -------
    - Ensures the returned commit hash matches the expected hash.
    """
    local_path = "/dummy/path"
    expected_hash = "abcdef1234567890abcdef1234567890abcdef12"

    # Patch subprocess.run to simulate successful git command
    with mock.patch("subprocess.run") as mock_run:
        mock_run.return_value = mock.Mock(returncode=0, stdout=expected_hash + "\n")

        # Call the function
        result = _get_repo_head_hash(local_path)

        # Check the function output and subprocess call arguments
        assert result == expected_hash
        mock_run.assert_called_once_with(
            f"git -C {local_path} rev-parse HEAD",
            shell=True,
            capture_output=True,
            text=True,
        )


def test_get_hash_from_checkout_target_direct_hash():
    """Test `_get_hash_from_checkout_target` to confirm it returns the input directly
    when `checkout_target` is already a valid 7-character or 40-character hash.

    Asserts
    -------
    - Ensures that `checkout_target` is returned directly if it matches a 7-character or
      40-character hash pattern.
    - Verifies `subprocess.run` is not called for direct hash inputs.
    """
    repo_url = "https://example.com/repo.git"

    # Test with a 7-character hash
    checkout_target_7 = "abcdef1"
    with mock.patch("subprocess.run") as mock_run:
        result_7 = _get_hash_from_checkout_target(repo_url, checkout_target_7)
        assert (
            result_7 == checkout_target_7
        ), f"Expected '{checkout_target_7}', got '{result_7}'"
        (
            mock_run.assert_not_called(),
            f"subprocess.run was called unexpectedly for 7-character hash '{checkout_target_7}'",
        )

    # Test with a 40-character hash
    checkout_target_40 = "abcdef1234567890abcdef1234567890abcdef12"
    with mock.patch("subprocess.run") as mock_run:
        result_40 = _get_hash_from_checkout_target(repo_url, checkout_target_40)
        assert (
            result_40 == checkout_target_40
        ), f"Expected '{checkout_target_40}', got '{result_40}'"
        (
            mock_run.assert_not_called(),
            f"subprocess.run was called unexpectedly for 40-character hash '{checkout_target_40}'",
        )


def test_get_hash_from_checkout_target_branch():
    """Test `_get_hash_from_checkout_target` to confirm it retrieves the correct hash
    when `checkout_target` is a branch or tag.

    Asserts
    -------
    - Ensures the correct hash is returned when `checkout_target` is not a direct hash.
    - Verifies `subprocess.run` is called with the correct `git ls-remote` command.
    """
    repo_url = "https://example.com/repo.git"
    checkout_target = "main"
    expected_hash = "abcdef1234567890abcdef1234567890abcdef12"

    # Patch subprocess.run to simulate successful `git ls-remote` command
    with mock.patch("subprocess.run") as mock_run:
        mock_run.return_value = mock.Mock(
            returncode=0, stdout=f"{expected_hash}\trefs/heads/main\n"
        )

        # Call the function
        result = _get_hash_from_checkout_target(repo_url, checkout_target)

        # Assert the correct hash is returned
        assert result == expected_hash

        # Check the subprocess call arguments
        mock_run.assert_called_once_with(
            f"git ls-remote {repo_url} {checkout_target}",
            shell=True,
            capture_output=True,
            text=True,
        )


def test_get_hash_from_checkout_target_invalid():
    """Test `_get_hash_from_checkout_target` when git ls-remote does not return a hash
    and `checkout_target` is not itself a valid hash.

    Asserts
    -------
    - a ValueError is raised
    - the error message matches an expected error message
    """
    repo_url = "https://example.com/repo.git"
    checkout_target = "pain"

    # Patch subprocess.run to simulate successful `git ls-remote` command
    with mock.patch("subprocess.run") as mock_run:
        mock_run.return_value = mock.Mock(returncode=0, stdout="")

        # Call the function
        with pytest.raises(ValueError) as exception_info:
            _get_hash_from_checkout_target(repo_url, checkout_target)

        expected_message = (
            "supplied checkout_target (pain) does not appear "
            + "to be a valid reference for this repository (https://example.com/repo.git)"
        )
        # Assert the correct hash is returned
        assert str(exception_info.value) == expected_message


class TestCalculateNodeDistribution:
    """Tests for `_calculate_node_distribution`, ensuring correct calculation of nodes
    and cores per node for various input scenarios."""

    def test_exact_division(self):
        """Test when `n_cores_required` is an exact multiple of `tot_cores_per_node`.

        Asserts
        -------
        - Ensures the correct number of nodes and cores per node are calculated.
        """
        n_cores_required = 256
        tot_cores_per_node = 64

        result = _calculate_node_distribution(n_cores_required, tot_cores_per_node)
        assert result == (4, 64), f"Expected (4, 64), got {result}"

    def test_partial_division(self):
        """Test when `n_cores_required` is not an exact multiple of
        `tot_cores_per_node`, requiring an extra node.

        Asserts
        -------
        - Ensures the correct number of nodes and cores per node are calculated.
        """
        n_cores_required = 300
        tot_cores_per_node = 64

        result = _calculate_node_distribution(n_cores_required, tot_cores_per_node)
        assert result == (5, 60), f"Expected (5, 60), got {result}"

    def test_single_node(self):
        """Test when `n_cores_required` is less than or equal to `tot_cores_per_node`,
        so only one node is required.

        Asserts
        -------
        - Ensures that a single node is requested with `n_cores_required` cores.
        """
        n_cores_required = 50
        tot_cores_per_node = 64

        result = _calculate_node_distribution(n_cores_required, tot_cores_per_node)
        assert result == (1, 50), f"Expected (1, 50), got {result}"

    def test_minimum_cores(self):
        """Test the edge case where `n_cores_required` is very low, such as 1.

        Asserts
        -------
        - Ensures that only one node is requested with the specified core count.
        """
        n_cores_required = 1
        tot_cores_per_node = 64

        result = _calculate_node_distribution(n_cores_required, tot_cores_per_node)
        assert result == (1, 1), f"Expected (1, 1), got {result}"


class TestReplaceTextInFile:
    """Tests for `_replace_text_in_file`, verifying correct behavior for text
    replacement within a file."""

    def setup_method(self):
        """Common setup for each test, initializing base content that can be modified
        per test."""
        self.base_content = "This is a test file with some old_text to replace."

    def test_replace_text_success(self, tmp_path):
        """Test that `_replace_text_in_file` successfully replaces the specified text
        when `old_text` is found in the file.

        Asserts
        -------
        - Ensures `old_text` is correctly replaced by `new_text`.
        - Verifies the function returns True when a replacement occurs.
        """
        # Create a temporary file and write the initial content
        test_file = tmp_path / "test_file.txt"
        test_file.write_text(self.base_content)

        # Run the function
        result = _replace_text_in_file(test_file, "old_text", "new_text")

        # Read the content and check the replacement
        updated_content = test_file.read_text()
        assert updated_content == "This is a test file with some new_text to replace."
        assert result is True, "Expected True when replacement occurs."

    def test_replace_text_not_found(self, tmp_path):
        """Test that `_replace_text_in_file` does not alter the file when `old_text` is
        not found, and returns False.

        Asserts
        -------
        - Ensures the file content remains unchanged when `old_text` is not found.
        - Verifies the function returns False when no replacement occurs.
        """
        # Create a temporary file and write initial content without `old_text`
        test_file = tmp_path / "test_file.txt"
        test_file.write_text("This is a test file without the target text.")

        # Run the function
        result = _replace_text_in_file(test_file, "non_existent_text", "new_text")

        # Read the content and check that no change occurred
        unchanged_content = test_file.read_text()
        assert unchanged_content == "This is a test file without the target text."
        assert result is False, "Expected False when no replacement occurs."

    def test_replace_text_multiple_occurrences(self, tmp_path):
        """Test that `_replace_text_in_file` replaces all occurrences of `old_text` when
        it appears multiple times in the file.

        Asserts
        -------
        - Ensures all instances of `old_text` are replaced by `new_text`.
        - Verifies the function returns True when replacement occurs.
        """
        # Create a temporary file with multiple instances of `old_text`
        test_file = tmp_path / "test_file.txt"
        test_file.write_text("old_text here, old_text there, and old_text everywhere.")

        # Run the function
        result = _replace_text_in_file(test_file, "old_text", "new_text")

        # Read the content and check that all occurrences were replaced
        updated_content = test_file.read_text()
        assert (
            updated_content == "new_text here, new_text there, and new_text everywhere."
        )
        assert result is True, "Expected True when multiple replacements occur."


class TestListToConciseStr:
    """Tests for `_list_to_concise_str`, verifying correct behavior under different list
    lengths and parameter configurations."""

    def test_basic_case_no_truncation(self):
        """Test `_list_to_concise_str` with a short list that does not exceed
        `item_threshold`.

        Asserts
        -------
        - Ensures the output is a full list representation with no truncation.
        """
        input_list = ["item1", "item2", "item3"]
        result = _list_to_concise_str(input_list, item_threshold=4, pad=0)
        assert result == "['item1',\n'item2',\n'item3']"

    def test_truncation_case(self):
        """Test `_list_to_concise_str` when the list length exceeds `item_threshold`,
        requiring truncation.

        Asserts
        -------
        - Ensures the output is truncated and includes the item count.
        """
        input_list = ["item1", "item2", "item3", "item4", "item5", "item6"]
        result = _list_to_concise_str(input_list, item_threshold=4, pad=0)
        assert result == "['item1',\n'item2',\n   ...\n'item6'] <6 items>"

    def test_padding_and_item_count_display(self):
        """Test `_list_to_concise_str` with custom padding and item count display
        enabled.

        Asserts
        -------
        - Ensures correct indentation and the presence of item count.
        """
        input_list = ["item1", "item2", "item3", "item4", "item5"]
        result = _list_to_concise_str(
            input_list, item_threshold=3, pad=10, show_item_count=True
        )
        expected_output = "['item1',\n          'item2',\n             ...\n          'item5'] <5 items>"
        assert result == expected_output

    def test_no_item_count_display(self):
        """Test `_list_to_concise_str` with `show_item_count=False` to verify that the
        item count is omitted in the truncated representation.

        Asserts
        -------
        - Ensures the item count is not included in the output.
        """
        input_list = ["item1", "item2", "item3", "item4", "item5"]
        result = _list_to_concise_str(
            input_list, item_threshold=3, pad=0, show_item_count=False
        )
        expected_output = "['item1',\n'item2',\n   ...\n'item5'] "
        assert result == expected_output


class TestDictToTree:
    """Tests for `_dict_to_tree`, verifying the correct tree-like string representation
    of various dictionary structures."""

    def test_simple_flat_dict(self):
        """Test `_dict_to_tree` with a single-level dictionary.

        Asserts
        -------
        - Ensures the output matches the expected flat tree representation.
        """
        input_dict = {"branch1": ["leaf1", "leaf2"], "branch2": ["leaf3"]}
        result = _dict_to_tree(input_dict)
        expected_output = (
            "├── branch1\n"
            "│   ├── leaf1\n"
            "│   └── leaf2\n"
            "└── branch2\n"
            "    └── leaf3\n"
        )
        assert result == expected_output

    def test_nested_dict(self):
        """Test `_dict_to_tree` with a multi-level nested dictionary.

        Asserts
        -------
        - Ensures the output matches the expected tree representation for nested dictionaries.
        """
        input_dict = {
            "branch1": {"twig1": ["leaf1", "leaf2"], "twig2": ["leaf3"]},
            "branch2": ["leaf4"],
        }
        result = _dict_to_tree(input_dict)
        expected_output = (
            "├── branch1\n"
            "│   ├── twig1\n"
            "│   │   ├── leaf1\n"
            "│   │   └── leaf2\n"
            "│   └── twig2\n"
            "│       └── leaf3\n"
            "└── branch2\n"
            "    └── leaf4\n"
        )
        assert result == expected_output

    def test_empty_dict(self):
        """Test `_dict_to_tree` with an empty dictionary.

        Asserts
        -------
        - Ensures that an empty dictionary returns an empty string.
        """
        input_dict = {}
        result = _dict_to_tree(input_dict)
        assert result == "", "Expected empty string for an empty dictionary."

    def test_complex_nested_structure(self):
        """Test `_dict_to_tree` with a complex nested dictionary containing various
        levels and mixed lists and dictionaries.

        Asserts
        -------
        - Ensures the output correctly represents the entire tree structure.
        """
        input_dict = {
            "branch1": {
                "twig1": {"twiglet1": ["leaf1"], "twiglet2": ["leaf2", "leaf3"]},
                "twig2": ["leaf4"],
            },
            "branch2": {"twig3": ["leaf5", "leaf6"]},
        }
        result = _dict_to_tree(input_dict)
        expected_output = (
            "├── branch1\n"
            "│   ├── twig1\n"
            "│   │   ├── twiglet1\n"
            "│   │   │   └── leaf1\n"
            "│   │   └── twiglet2\n"
            "│   │       ├── leaf2\n"
            "│   │       └── leaf3\n"
            "│   └── twig2\n"
            "│       └── leaf4\n"
            "└── branch2\n"
            "    └── twig3\n"
            "        ├── leaf5\n"
            "        └── leaf6\n"
        )
        assert result == expected_output
